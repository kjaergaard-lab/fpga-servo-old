library IEEE;
use ieee.std_logic_1164.all; 
use ieee.numeric_std.ALL;
use ieee.std_logic_unsigned.all; 
use work.Constants.all;

--
-- This entity is a wrapper for the memory controller generated by Xilinx's MIG.  
-- The read/write protocol here is very simple but suffices for low read and write
-- rates.
--
entity LPDDRControl is
port
  (
	--
	-- Physical memory signals
	--
   mcb3_dram_dq                            : inout  std_logic_vector(DDR_NUM_DQ_PINS-1 downto 0);
   mcb3_dram_a                             : out std_logic_vector(DDR_ADDR_WIDTH-1 downto 0);
   mcb3_dram_ba                            : out std_logic_vector(DDR_BANK_WIDTH-1 downto 0);
   mcb3_dram_cke                           : out std_logic;
   mcb3_dram_ras_n                         : out std_logic;
   mcb3_dram_cas_n                         : out std_logic;
   mcb3_dram_we_n                          : out std_logic;
   mcb3_dram_dm                            : out std_logic;
   mcb3_dram_udqs                          : inout  std_logic;
   mcb3_rzq                                : inout  std_logic;
   mcb3_dram_udm                           : out std_logic;
   c3_sys_clk                              : in  std_logic;
   c3_sys_rst_n                            : in  std_logic;
   c3_calib_done                           : out std_logic;
   c3_clk0                                 : out std_logic;
   c3_rst0                                 : out std_logic;
   mcb3_dram_dqs                           : inout  std_logic;
   mcb3_dram_ck                            : out std_logic;
   mcb3_dram_ck_n                          : out std_logic;
	
	--
	-- Clock for user logic
	--
	clk			:	in	std_logic;
	--
	-- User signals - port 0
	--
	trigWrite0	:	in std_logic;
	trigRead0	:	in std_logic;
	dataIn0		:	in std_logic_vector(MEM_DATA_WIDTH-1 downto 0);
	dataOut0		:	out std_logic_vector(MEM_DATA_WIDTH-1 downto 0);
	dataReady0	:	out std_logic;
	addrRead0	:	in	unsigned(MEM_ADDR_WIDTH-1 downto 0);
	addrWrite0	:	in	unsigned(MEM_ADDR_WIDTH-1 downto 0);
	
	rd_error0	:	out	std_logic;
	wr_error0	:	out	std_logic;
	--
	-- User signals - port 1
	--
	trigWrite1	:	in std_logic;
	trigRead1	:	in std_logic;
	dataIn1		:	in std_logic_vector(MEM_DATA_WIDTH-1 downto 0);
	dataOut1		:	out std_logic_vector(MEM_DATA_WIDTH-1 downto 0);
	dataReady1	:	out std_logic;
	addrRead1	:	in	unsigned(MEM_ADDR_WIDTH-1 downto 0);
	addrWrite1	:	in	unsigned(MEM_ADDR_WIDTH-1 downto 0);
	
	rd_error1	:	out	std_logic;
	wr_error1	:	out	std_logic;
	--
	-- User signals - port 2
	--
	trigWrite2	:	in std_logic;
	trigRead2	:	in std_logic;
	dataIn2		:	in std_logic_vector(MEM_DATA_WIDTH-1 downto 0);
	dataOut2		:	out std_logic_vector(MEM_DATA_WIDTH-1 downto 0);
	dataReady2	:	out std_logic;
	addrRead2	:	in	unsigned(MEM_ADDR_WIDTH-1 downto 0);
	addrWrite2	:	in	unsigned(MEM_ADDR_WIDTH-1 downto 0);
	
	rd_error2	:	out	std_logic;
	wr_error2	:	out	std_logic;
	--
	-- User signals - port 3
	--
	trigWrite3	:	in std_logic;
	trigRead3	:	in std_logic;
	dataIn3		:	in std_logic_vector(MEM_DATA_WIDTH-1 downto 0);
	dataOut3		:	out std_logic_vector(MEM_DATA_WIDTH-1 downto 0);
	dataReady3	:	out std_logic;
	addrRead3	:	in	unsigned(MEM_ADDR_WIDTH-1 downto 0);
	addrWrite3	:	in	unsigned(MEM_ADDR_WIDTH-1 downto 0);
	
	rd_error3	:	out	std_logic;
	wr_error3	:	out	std_logic
	);
end LPDDRControl;

architecture Behavioral of LPDDRControl is


component s6_lpddr_4channel is
	generic
	(
	C3_P0_MASK_SIZE           : integer := 4;
	C3_P0_DATA_PORT_SIZE      : integer := 32;
	C3_P1_MASK_SIZE           : integer := 4;
	C3_P1_DATA_PORT_SIZE      : integer := 32;
    C3_MEMCLK_PERIOD        : integer := 10000; 
                                       -- Memory data transfer clock period.
    C3_RST_ACT_LOW          : integer := 0; 
                                       -- # = 1 for active low reset,
                                       -- # = 0 for active high reset.
    C3_INPUT_CLK_TYPE       : string := "SINGLE_ENDED"; 
                                       -- input clock type DIFFERENTIAL or SINGLE_ENDED.
    C3_CALIB_SOFT_IP        : string := "TRUE"; 
                                       -- # = TRUE, Enables the soft calibration logic,
                                       -- # = FALSE, Disables the soft calibration logic.
    C3_SIMULATION           : string := "FALSE"; 
                                       -- # = TRUE, Simulating the design. Useful to reduce the simulation time,
                                       -- # = FALSE, Implementing the design.
    DEBUG_EN                : integer := 0; 
                                       -- # = 1, Enable debug signals/controls,
                                       --   = 0, Disable debug signals/controls.
    C3_MEM_ADDR_ORDER       : string := "ROW_BANK_COLUMN"; 
                                       -- The order in which user address is provided to the memory controller,
                                       -- ROW_BANK_COLUMN or BANK_ROW_COLUMN.
    C3_NUM_DQ_PINS          : integer := 16; 
                                       -- External memory data width.
    C3_MEM_ADDR_WIDTH       : integer := 13; 
                                       -- External memory address width.
    C3_MEM_BANKADDR_WIDTH   : integer := 2 
                                       -- External memory bank address width.
  );
   
  port
  (

   mcb3_dram_dq                            : inout  std_logic_vector(C3_NUM_DQ_PINS-1 downto 0);
   mcb3_dram_a                             : out std_logic_vector(C3_MEM_ADDR_WIDTH-1 downto 0);
   mcb3_dram_ba                            : out std_logic_vector(C3_MEM_BANKADDR_WIDTH-1 downto 0);
   mcb3_dram_cke                           : out std_logic;
   mcb3_dram_ras_n                         : out std_logic;
   mcb3_dram_cas_n                         : out std_logic;
   mcb3_dram_we_n                          : out std_logic;
   mcb3_dram_dm                            : out std_logic;
   mcb3_dram_udqs                          : inout  std_logic;
   mcb3_rzq                                : inout  std_logic;
   mcb3_dram_udm                           : out std_logic;
   c3_sys_clk                              : in  std_logic;
   c3_sys_rst_n                            : in  std_logic;
   c3_calib_done                           : out std_logic;
   c3_clk0                                 : out std_logic;
   c3_rst0                                 : out std_logic;
   mcb3_dram_dqs                           : inout  std_logic;
   mcb3_dram_ck                            : out std_logic;
   mcb3_dram_ck_n                          : out std_logic;
   c3_p0_cmd_clk                           : in std_logic;
   c3_p0_cmd_en                            : in std_logic;
   c3_p0_cmd_instr                         : in std_logic_vector(2 downto 0);
   c3_p0_cmd_bl                            : in std_logic_vector(5 downto 0);
   c3_p0_cmd_byte_addr                     : in std_logic_vector(29 downto 0);
   c3_p0_cmd_empty                         : out std_logic;
   c3_p0_cmd_full                          : out std_logic;
   c3_p0_wr_clk                            : in std_logic;
   c3_p0_wr_en                             : in std_logic;
   c3_p0_wr_mask                           : in std_logic_vector(C3_P0_MASK_SIZE - 1 downto 0);
   c3_p0_wr_data                           : in std_logic_vector(C3_P0_DATA_PORT_SIZE - 1 downto 0);
   c3_p0_wr_full                           : out std_logic;
   c3_p0_wr_empty                          : out std_logic;
   c3_p0_wr_count                          : out std_logic_vector(6 downto 0);
   c3_p0_wr_underrun                       : out std_logic;
   c3_p0_wr_error                          : out std_logic;
   c3_p0_rd_clk                            : in std_logic;
   c3_p0_rd_en                             : in std_logic;
   c3_p0_rd_data                           : out std_logic_vector(C3_P0_DATA_PORT_SIZE - 1 downto 0);
   c3_p0_rd_full                           : out std_logic;
   c3_p0_rd_empty                          : out std_logic;
   c3_p0_rd_count                          : out std_logic_vector(6 downto 0);
   c3_p0_rd_overflow                       : out std_logic;
   c3_p0_rd_error                          : out std_logic;
   c3_p1_cmd_clk                           : in std_logic;
   c3_p1_cmd_en                            : in std_logic;
   c3_p1_cmd_instr                         : in std_logic_vector(2 downto 0);
   c3_p1_cmd_bl                            : in std_logic_vector(5 downto 0);
   c3_p1_cmd_byte_addr                     : in std_logic_vector(29 downto 0);
   c3_p1_cmd_empty                         : out std_logic;
   c3_p1_cmd_full                          : out std_logic;
   c3_p1_wr_clk                            : in std_logic;
   c3_p1_wr_en                             : in std_logic;
   c3_p1_wr_mask                           : in std_logic_vector(C3_P1_MASK_SIZE - 1 downto 0);
   c3_p1_wr_data                           : in std_logic_vector(C3_P1_DATA_PORT_SIZE - 1 downto 0);
   c3_p1_wr_full                           : out std_logic;
   c3_p1_wr_empty                          : out std_logic;
   c3_p1_wr_count                          : out std_logic_vector(6 downto 0);
   c3_p1_wr_underrun                       : out std_logic;
   c3_p1_wr_error                          : out std_logic;
   c3_p1_rd_clk                            : in std_logic;
   c3_p1_rd_en                             : in std_logic;
   c3_p1_rd_data                           : out std_logic_vector(C3_P1_DATA_PORT_SIZE - 1 downto 0);
   c3_p1_rd_full                           : out std_logic;
   c3_p1_rd_empty                          : out std_logic;
   c3_p1_rd_count                          : out std_logic_vector(6 downto 0);
   c3_p1_rd_overflow                       : out std_logic;
   c3_p1_rd_error                          : out std_logic;
   c3_p2_cmd_clk                           : in std_logic;
   c3_p2_cmd_en                            : in std_logic;
   c3_p2_cmd_instr                         : in std_logic_vector(2 downto 0);
   c3_p2_cmd_bl                            : in std_logic_vector(5 downto 0);
   c3_p2_cmd_byte_addr                     : in std_logic_vector(29 downto 0);
   c3_p2_cmd_empty                         : out std_logic;
   c3_p2_cmd_full                          : out std_logic;
   c3_p2_wr_clk                            : in std_logic;
   c3_p2_wr_en                             : in std_logic;
   c3_p2_wr_mask                           : in std_logic_vector(3 downto 0);
   c3_p2_wr_data                           : in std_logic_vector(31 downto 0);
   c3_p2_wr_full                           : out std_logic;
   c3_p2_wr_empty                          : out std_logic;
   c3_p2_wr_count                          : out std_logic_vector(6 downto 0);
   c3_p2_wr_underrun                       : out std_logic;
   c3_p2_wr_error                          : out std_logic;
   c3_p2_rd_clk                            : in std_logic;
   c3_p2_rd_en                             : in std_logic;
   c3_p2_rd_data                           : out std_logic_vector(31 downto 0);
   c3_p2_rd_full                           : out std_logic;
   c3_p2_rd_empty                          : out std_logic;
   c3_p2_rd_count                          : out std_logic_vector(6 downto 0);
   c3_p2_rd_overflow                       : out std_logic;
   c3_p2_rd_error                          : out std_logic;
   c3_p3_cmd_clk                           : in std_logic;
   c3_p3_cmd_en                            : in std_logic;
   c3_p3_cmd_instr                         : in std_logic_vector(2 downto 0);
   c3_p3_cmd_bl                            : in std_logic_vector(5 downto 0);
   c3_p3_cmd_byte_addr                     : in std_logic_vector(29 downto 0);
   c3_p3_cmd_empty                         : out std_logic;
   c3_p3_cmd_full                          : out std_logic;
   c3_p3_wr_clk                            : in std_logic;
   c3_p3_wr_en                             : in std_logic;
   c3_p3_wr_mask                           : in std_logic_vector(3 downto 0);
   c3_p3_wr_data                           : in std_logic_vector(31 downto 0);
   c3_p3_wr_full                           : out std_logic;
   c3_p3_wr_empty                          : out std_logic;
   c3_p3_wr_count                          : out std_logic_vector(6 downto 0);
   c3_p3_wr_underrun                       : out std_logic;
   c3_p3_wr_error                          : out std_logic;
   c3_p3_rd_clk                            : in std_logic;
   c3_p3_rd_en                             : in std_logic;
   c3_p3_rd_data                           : out std_logic_vector(31 downto 0);
   c3_p3_rd_full                           : out std_logic;
   c3_p3_rd_empty                          : out std_logic;
   c3_p3_rd_count                          : out std_logic_vector(6 downto 0);
   c3_p3_rd_overflow                       : out std_logic;
   c3_p3_rd_error                          : out std_logic
  );
end component;

--------------------------------------------
--------- Memory Signals - Port 0 ----------
--------------------------------------------
signal cmd_en0, cmd_empty0, cmd_full0	:	std_logic	:= '0';
signal cmd_instr0	:	std_logic_vector(2 downto 0)	:=	"000";
signal cmd_bl0		:	std_logic_vector(5 downto 0)	:= (others => '0');
signal cmd_addr0, cmdAddrRead0, cmdAddrWrite0	:	std_logic_vector(29 downto 0) := (others => '0');

signal wr_en0, wr_full0, wr_empty0, wr_underrun0	:	std_logic := '0';
signal wr_mask0		: std_logic_vector(MEM_MASK_SIZE - 1 downto 0) := (others => '0');
signal wr_count0	: std_logic_vector(6 downto 0)	:=	(others => '0');
signal wr_data0	:	std_logic_vector(MEM_DATA_WIDTH-1 downto 0)	:=	(others => '0');

signal rd_en0, rd_full0, rd_empty0, rd_overflow0	:	std_logic := '0';
signal rd_count0	: std_logic_vector(6 downto 0)	:=	(others => '0');
signal rd_data0	:	std_logic_vector(MEM_DATA_WIDTH-1 downto 0)	:=	(others => '0');


---------------------------------------------
----- State Machine Signals - Port 0  -------
---------------------------------------------
signal stateWrite0	: unsigned(3 downto 0)	:=	X"0";
signal stateRead0	: unsigned(3 downto 0)	:=	X"0";



--------------------------------------------
--------- Memory Signals - Port 1 ----------
--------------------------------------------
signal cmd_en1, cmd_empty1, cmd_full1	:	std_logic	:= '0';
signal cmd_instr1	:	std_logic_vector(2 downto 0)	:=	"000";
signal cmd_bl1		:	std_logic_vector(5 downto 0)	:= (others => '0');
signal cmd_addr1, cmdAddrRead1, cmdAddrWrite1	:	std_logic_vector(29 downto 0) := (others => '0');

signal wr_en1, wr_full1, wr_empty1, wr_underrun1	:	std_logic := '0';
signal wr_mask1		: std_logic_vector(MEM_MASK_SIZE - 1 downto 0) := (others => '0');
signal wr_count1	: std_logic_vector(6 downto 0)	:=	(others => '0');
signal wr_data1	:	std_logic_vector(MEM_DATA_WIDTH-1 downto 0)	:=	(others => '0');

signal rd_en1, rd_full1, rd_empty1, rd_overflow1	:	std_logic := '0';
signal rd_count1	: std_logic_vector(6 downto 0)	:=	(others => '0');
signal rd_data1	:	std_logic_vector(MEM_DATA_WIDTH-1 downto 0)	:=	(others => '0');


---------------------------------------------
----- State Machine Signals - Port 1  -------
---------------------------------------------
signal stateWrite1	: unsigned(3 downto 0)	:=	X"0";
signal stateRead1	: unsigned(3 downto 0)	:=	X"0";

--------------------------------------------
--------- Memory Signals - Port 2 ----------
--------------------------------------------
signal cmd_en2, cmd_empty2, cmd_full2	:	std_logic	:= '0';
signal cmd_instr2	:	std_logic_vector(2 downto 0)	:=	"000";
signal cmd_bl2		:	std_logic_vector(5 downto 0)	:= (others => '0');
signal cmd_addr2, cmdAddrRead2, cmdAddrWrite2	:	std_logic_vector(29 downto 0) := (others => '0');

signal wr_en2, wr_full2, wr_empty2, wr_underrun2	:	std_logic := '0';
signal wr_mask2		: std_logic_vector(MEM_MASK_SIZE - 1 downto 0) := (others => '0');
signal wr_count2	: std_logic_vector(6 downto 0)	:=	(others => '0');
signal wr_data2	:	std_logic_vector(MEM_DATA_WIDTH-1 downto 0)	:=	(others => '0');

signal rd_en2, rd_full2, rd_empty2, rd_overflow2	:	std_logic := '0';
signal rd_count2	: std_logic_vector(6 downto 0)	:=	(others => '0');
signal rd_data2	:	std_logic_vector(MEM_DATA_WIDTH-1 downto 0)	:=	(others => '0');


---------------------------------------------
----- State Machine Signals - Port 2  -------
---------------------------------------------
signal stateWrite2	: unsigned(3 downto 0)	:=	X"0";
signal stateRead2	: unsigned(3 downto 0)	:=	X"0";


--------------------------------------------
--------- Memory Signals - Port 3 ----------
--------------------------------------------
signal cmd_en3, cmd_empty3, cmd_full3	:	std_logic	:= '0';
signal cmd_instr3	:	std_logic_vector(2 downto 0)	:=	"000";
signal cmd_bl3		:	std_logic_vector(5 downto 0)	:= (others => '0');
signal cmd_addr3, cmdAddrRead3, cmdAddrWrite3	:	std_logic_vector(29 downto 0) := (others => '0');

signal wr_en3, wr_full3, wr_empty3, wr_underrun3	:	std_logic := '0';
signal wr_mask3		: std_logic_vector(MEM_MASK_SIZE - 1 downto 0) := (others => '0');
signal wr_count3	: std_logic_vector(6 downto 0)	:=	(others => '0');
signal wr_data3	:	std_logic_vector(MEM_DATA_WIDTH-1 downto 0)	:=	(others => '0');

signal rd_en3, rd_full3, rd_empty3, rd_overflow3	:	std_logic := '0';
signal rd_count3	: std_logic_vector(6 downto 0)	:=	(others => '0');
signal rd_data3	:	std_logic_vector(MEM_DATA_WIDTH-1 downto 0)	:=	(others => '0');


---------------------------------------------
----- State Machine Signals - Port 3  -------
---------------------------------------------
signal stateWrite3	: unsigned(3 downto 0)	:=	X"0";
signal stateRead3	: unsigned(3 downto 0)	:=	X"0";


begin


MemWrapper: s6_lpddr_4channel port map (
	mcb3_dram_dq => mcb3_dram_dq,
   mcb3_dram_a => mcb3_dram_a,
   mcb3_dram_ba => mcb3_dram_ba,
   mcb3_dram_cke => mcb3_dram_cke,
   mcb3_dram_ras_n => mcb3_dram_ras_n,
   mcb3_dram_cas_n => mcb3_dram_cas_n,
   mcb3_dram_we_n => mcb3_dram_we_n,
   mcb3_dram_dm => mcb3_dram_dm,
   mcb3_dram_udqs => mcb3_dram_udqs,
   mcb3_rzq => mcb3_rzq,
   mcb3_dram_udm => mcb3_dram_udm,
   c3_sys_clk => c3_sys_clk,
   c3_sys_rst_n => c3_sys_rst_n,
   c3_calib_done => c3_calib_done,
   c3_clk0 => c3_clk0,
   c3_rst0 => c3_rst0,
   mcb3_dram_dqs => mcb3_dram_dqs,
   mcb3_dram_ck => mcb3_dram_ck,
   mcb3_dram_ck_n => mcb3_dram_ck_n,
	
	--Port 0
   c3_p0_cmd_clk => clk,
   c3_p0_cmd_en => cmd_en0,
   c3_p0_cmd_instr => cmd_instr0,
   c3_p0_cmd_bl => cmd_bl0,
   c3_p0_cmd_byte_addr => cmd_addr0,
   c3_p0_cmd_empty => cmd_empty0,
   c3_p0_cmd_full => cmd_full0,
   c3_p0_wr_clk => clk,
   c3_p0_wr_en => wr_en0,
   c3_p0_wr_mask => wr_mask0,
   c3_p0_wr_data => wr_data0,
   c3_p0_wr_full => wr_full0,
   c3_p0_wr_empty => wr_empty0,
   c3_p0_wr_count => wr_count0,
   c3_p0_wr_underrun => wr_underrun0,
   c3_p0_wr_error => wr_error0,
   c3_p0_rd_clk => clk,
   c3_p0_rd_en => rd_en0,
   c3_p0_rd_data => rd_data0,
   c3_p0_rd_full => rd_full0,
   c3_p0_rd_empty => rd_empty0,
   c3_p0_rd_count => rd_count0,
   c3_p0_rd_overflow => rd_overflow0,
   c3_p0_rd_error => rd_error0,
	
	--Port 1
   c3_p1_cmd_clk => clk,
   c3_p1_cmd_en => cmd_en1,
   c3_p1_cmd_instr => cmd_instr1,
   c3_p1_cmd_bl => cmd_bl1,
   c3_p1_cmd_byte_addr => cmd_addr1,
   c3_p1_cmd_empty => cmd_empty1,
   c3_p1_cmd_full => cmd_full1,
   c3_p1_wr_clk => clk,
   c3_p1_wr_en => wr_en1,
   c3_p1_wr_mask => wr_mask1,
   c3_p1_wr_data => wr_data1,
   c3_p1_wr_full => wr_full1,
   c3_p1_wr_empty => wr_empty1,
   c3_p1_wr_count => wr_count1,
   c3_p1_wr_underrun => wr_underrun1,
   c3_p1_wr_error => wr_error1,
   c3_p1_rd_clk => clk,
   c3_p1_rd_en => rd_en1,
   c3_p1_rd_data => rd_data1,
   c3_p1_rd_full => rd_full1,
   c3_p1_rd_empty => rd_empty1,
   c3_p1_rd_count => rd_count1,
   c3_p1_rd_overflow => rd_overflow1,
   c3_p1_rd_error => rd_error1,
	
	--Port 2
   c3_p2_cmd_clk => clk,
   c3_p2_cmd_en => cmd_en2,
   c3_p2_cmd_instr => cmd_instr2,
   c3_p2_cmd_bl => cmd_bl2,
   c3_p2_cmd_byte_addr => cmd_addr2,
   c3_p2_cmd_empty => cmd_empty2,
   c3_p2_cmd_full => cmd_full2,
   c3_p2_wr_clk => clk,
   c3_p2_wr_en => wr_en2,
   c3_p2_wr_mask => wr_mask2,
   c3_p2_wr_data => wr_data2,
   c3_p2_wr_full => wr_full2,
   c3_p2_wr_empty => wr_empty2,
   c3_p2_wr_count => wr_count2,
   c3_p2_wr_underrun => wr_underrun2,
   c3_p2_wr_error => wr_error2,
   c3_p2_rd_clk => clk,
   c3_p2_rd_en => rd_en2,
   c3_p2_rd_data => rd_data2,
   c3_p2_rd_full => rd_full2,
   c3_p2_rd_empty => rd_empty2,
   c3_p2_rd_count => rd_count2,
   c3_p2_rd_overflow => rd_overflow2,
   c3_p2_rd_error => rd_error2,
	
	--Port 3
   c3_p3_cmd_clk => clk,
   c3_p3_cmd_en => cmd_en3,
   c3_p3_cmd_instr => cmd_instr3,
   c3_p3_cmd_bl => cmd_bl3,
   c3_p3_cmd_byte_addr => cmd_addr3,
   c3_p3_cmd_empty => cmd_empty3,
   c3_p3_cmd_full => cmd_full3,
   c3_p3_wr_clk => clk,
   c3_p3_wr_en => wr_en3,
   c3_p3_wr_mask => wr_mask3,
   c3_p3_wr_data => wr_data3,
   c3_p3_wr_full => wr_full3,
   c3_p3_wr_empty => wr_empty3,
   c3_p3_wr_count => wr_count3,
   c3_p3_wr_underrun => wr_underrun3,
   c3_p3_wr_error => wr_error3,
   c3_p3_rd_clk => clk,
   c3_p3_rd_en => rd_en3,
   c3_p3_rd_data => rd_data3,
   c3_p3_rd_full => rd_full3,
   c3_p3_rd_empty => rd_empty3,
   c3_p3_rd_count => rd_count3,
   c3_p3_rd_overflow => rd_overflow3,
   c3_p3_rd_error => rd_error3
	
);

--
-- This process acts controls two finite-state machines that handle
-- the write and read timing for the memory.  For write/read/command
-- path timing information, refer to UG388 from Xilinx, pages 52-54.
--
StateMachine0: process(clk,trigWrite0,trigRead0) is
begin
	if rising_edge(clk) then
		--
		-- This case statement handles the process of writing data to
		-- the memory.
		--
		WriteCase0: case stateWrite0 is
			--
			-- Idle state.  Waits for a write trigger, 
			-- then latches the write address into an internal signal
			--
			when X"0" =>
				if trigWrite0 = '1' then
					wr_data0 <= dataIn0;
					cmdAddrWrite0 <= std_logic_vector(addrWrite0) & "00";
					stateWrite0 <= stateWrite0 + X"1";
				end if;
			
			--
			-- Wait until the write buffer has room and no read transactions
			-- are occurring.  Then tell the controller that a write instruction
			-- follows with one memory location to be written to.
			--
			-- Data is written into the write buffer on subsequent clock edges
			--
			when X"1" =>
				if wr_full0 = '0' and stateRead0 = X"0" then
					wr_en0 <= '1';
					stateWrite0 <= stateWrite0 + X"1";
					cmd_instr0 <= "000";		--This specifies a write command
					cmd_bl0 <= "000000";
					cmd_addr0 <= cmdAddrWrite0;
				end if;
			
			--
			-- De-asserts the write-enable signal
			--
			when X"2" =>
				wr_en0 <= '0';
				stateWrite0 <= stateWrite0 + X"1";
				
			--
			-- Waits for the write buffer to empty before proceeding
			--
			when X"3" => 
				if wr_empty0 = '0' then
					stateWrite0 <= stateWrite0 +X"1";
				end if;
				
			--
			-- This is the actual command that writes data from
			-- the write buffer into the memory
			--
			when X"4" =>
				cmd_en0 <= '1';
				stateWrite0 <= stateWrite0 + X"1";
				
			--
			-- De-assert the cmd_en signal.
			--
			when X"5" =>
				cmd_en0 <= '0';
				stateWrite0 <= stateWrite0 + X"1";
				
			--
			-- Wait until the write buffer is empty before
			-- returning to the idle state
			--
			when X"6" =>
				if wr_empty0 = '1' then
					stateWrite0 <= X"0";
				end if;
			
			when others => null;
		end case;
		
		--
		-- This case statement handles the process of reading data
		-- from the memory.
		--
		ReadCase0: case stateRead0 is
			--
			-- Idle state.  Waits for a read trigger, then latches the address
			-- into an internral signal.
			--
			when X"0" =>
				if trigRead0 = '1' then
					cmdAddrRead0 <= std_logic_vector(addrRead0) & "00";					
					stateRead0 <= stateRead0 + X"1";
				else
					dataReady0 <= '0';
				end if;
			
			--
			-- Waits until the read buffer is empty and no write transactions are occurring.
			-- Sends address to command signal for memory.
			--
			when X"1" =>
				if rd_empty0 = '1' and (stateWrite0 = X"0" or stateWrite0 = X"1") then
					cmd_instr0 <= "001";		--This specifies a read command
					cmd_bl0 <= "000000";
					cmd_addr0 <= cmdAddrRead0;
					stateRead0 <= stateRead0 + X"1";
				end if;
				
			--
			-- Assert the cmd_en signal to write the cmd_instr to the
			-- controller
			--
			when X"2" =>
				cmd_en0 <= '1';
				stateRead0 <= stateRead0 + X"1";
				
			--
			-- De-assert the cmd_en signal
			--
			when X"3" =>
				cmd_en0 <= '0';
				stateRead0 <= stateRead0 + X"1";
				
			--
			-- Wait until the read buffer has data before proceeding
			--
			when X"4" =>
				if rd_empty0 = '0' then
					stateRead0 <= stateRead0 + X"1";
				end if;
				
			--
			-- Assert the rd_en signal to start pulling data from the read buffer
			--
			when X"5" =>
				rd_en0 <= '1';
				stateRead0 <= stateRead0 + X"1";
			
			--
			-- Read data is now valid.  Retrieve the data from the read buffer (rd_data)
			-- and assert that the data is valid to outside entities.
			--
			when X"6" =>
				rd_en0 <= '0';
				dataOut0 <= rd_data0;
				dataReady0 <= '1';
				stateRead0 <= stateRead0 + X"1";
			
			--
			-- De-assert the dataReady signal and return to idle state
			--
			when X"7" =>
				stateRead0 <= X"0";
				dataReady0 <= '0';
		
			when others => null;
		end case;
	end if;	--End rising_edge
end process;


StateMachine1: process(clk,trigWrite1,trigRead1) is
begin
	if rising_edge(clk) then
		--
		-- This case statement handles the process of writing data to
		-- the memory.
		--
		WriteCase1: case stateWrite1 is
			--
			-- Idle state.  Waits for a write trigger, 
			-- then latches the write address into an internal signal
			--
			when X"0" =>
				if trigWrite1 = '1' then
					wr_data1 <= dataIn1;
					cmdAddrWrite1 <= std_logic_vector(addrWrite1) & "00";
					stateWrite1 <= stateWrite1 + X"1";
				end if;
			
			--
			-- Wait until the write buffer has room and no read transactions
			-- are occurring.  Then tell the controller that a write instruction
			-- follows with one memory location to be written to.
			--
			-- Data is written into the write buffer on subsequent clock edges
			--
			when X"1" =>
				if wr_full1 = '0' and stateRead1 = X"0" then
					wr_en1 <= '1';
					stateWrite1 <= stateWrite1 + X"1";
					cmd_instr1 <= "000";		--This specifies a write command
					cmd_bl1 <= "000000";
					cmd_addr1 <= cmdAddrWrite1;
				end if;
			
			--
			-- De-asserts the write-enable signal
			--
			when X"2" =>
				wr_en1 <= '0';
				stateWrite1 <= stateWrite1 + X"1";
				
			--
			-- Waits for the write buffer to empty before proceeding
			--
			when X"3" => 
				if wr_empty1 = '0' then
					stateWrite1 <= stateWrite1 +X"1";
				end if;
				
			--
			-- This is the actual command that writes data from
			-- the write buffer into the memory
			--
			when X"4" =>
				cmd_en1 <= '1';
				stateWrite1 <= stateWrite1 + X"1";
				
			--
			-- De-assert the cmd_en signal.
			--
			when X"5" =>
				cmd_en1 <= '0';
				stateWrite1 <= stateWrite1 + X"1";
				
			--
			-- Wait until the write buffer is empty before
			-- returning to the idle state
			--
			when X"6" =>
				if wr_empty1 = '1' then
					stateWrite1 <= X"0";
				end if;
			
			when others => null;
		end case;
		
		--
		-- This case statement handles the process of reading data
		-- from the memory.
		--
		ReadCase1: case stateRead1 is
			--
			-- Idle state.  Waits for a read trigger, then latches the address
			-- into an internral signal.
			--
			when X"0" =>
				if trigRead1 = '1' then
					cmdAddrRead1 <= std_logic_vector(addrRead1) & "00";					
					stateRead1 <= stateRead1 + X"1";
				else
					dataReady1 <= '0';
				end if;
			
			--
			-- Waits until the read buffer is empty and no write transactions are occurring.
			-- Sends address to command signal for memory.
			--
			when X"1" =>
				if rd_empty1 = '1' and (stateWrite1 = X"0" or stateWrite1 = X"1") then
					cmd_instr1 <= "001";		--This specifies a read command
					cmd_bl1 <= "000000";
					cmd_addr1 <= cmdAddrRead1;
					stateRead1 <= stateRead1 + X"1";
				end if;
				
			--
			-- Assert the cmd_en signal to write the cmd_instr to the
			-- controller
			--
			when X"2" =>
				cmd_en1 <= '1';
				stateRead1 <= stateRead1 + X"1";
				
			--
			-- De-assert the cmd_en signal
			--
			when X"3" =>
				cmd_en1 <= '0';
				stateRead1 <= stateRead1 + X"1";
				
			--
			-- Wait until the read buffer has data before proceeding
			--
			when X"4" =>
				if rd_empty1 = '0' then
					stateRead1 <= stateRead1 + X"1";
				end if;
				
			--
			-- Assert the rd_en signal to start pulling data from the read buffer
			--
			when X"5" =>
				rd_en1 <= '1';
				stateRead1 <= stateRead1 + X"1";
			
			--
			-- Read data is now valid.  Retrieve the data from the read buffer (rd_data)
			-- and assert that the data is valid to outside entities.
			--
			when X"6" =>
				rd_en1 <= '0';
				dataOut1 <= rd_data1;
				dataReady1 <= '1';
				stateRead1 <= stateRead1 + X"1";
			
			--
			-- De-assert the dataReady signal and return to idle state
			--
			when X"7" =>
				stateRead1 <= X"0";
				dataReady1 <= '0';
		
			when others => null;
		end case;
	end if;	--End rising_edge
end process;

StateMachine2: process(clk,trigWrite2,trigRead2) is
begin
	if rising_edge(clk) then
		--
		-- This case statement handles the process of writing data to
		-- the memory.
		--
		WriteCase2: case stateWrite2 is
			--
			-- Idle state.  Waits for a write trigger, 
			-- then latches the write address into an internal signal
			--
			when X"0" =>
				if trigWrite2 = '1' then
					wr_data2 <= dataIn2;
					cmdAddrWrite2 <= std_logic_vector(addrWrite2) & "00";
					stateWrite2 <= stateWrite2 + X"1";
				end if;
			
			--
			-- Wait until the write buffer has room and no read transactions
			-- are occurring.  Then tell the controller that a write instruction
			-- follows with one memory location to be written to.
			--
			-- Data is written into the write buffer on subsequent clock edges
			--
			when X"1" =>
				if wr_full2 = '0' and stateRead2 = X"0" then
					wr_en2 <= '1';
					stateWrite2 <= stateWrite2 + X"1";
					cmd_instr2 <= "000";		--This specifies a write command
					cmd_bl2 <= "000000";
					cmd_addr2 <= cmdAddrWrite2;
				end if;
			
			--
			-- De-asserts the write-enable signal
			--
			when X"2" =>
				wr_en2 <= '0';
				stateWrite2 <= stateWrite2 + X"1";
				
			--
			-- Waits for the write buffer to empty before proceeding
			--
			when X"3" => 
				if wr_empty2 = '0' then
					stateWrite2 <= stateWrite2 +X"1";
				end if;
				
			--
			-- This is the actual command that writes data from
			-- the write buffer into the memory
			--
			when X"4" =>
				cmd_en2 <= '1';
				stateWrite2 <= stateWrite2 + X"1";
				
			--
			-- De-assert the cmd_en signal.
			--
			when X"5" =>
				cmd_en2 <= '0';
				stateWrite2 <= stateWrite2 + X"1";
				
			--
			-- Wait until the write buffer is empty before
			-- returning to the idle state
			--
			when X"6" =>
				if wr_empty2 = '1' then
					stateWrite2 <= X"0";
				end if;
			
			when others => null;
		end case;
		
		--
		-- This case statement handles the process of reading data
		-- from the memory.
		--
		ReadCase2: case stateRead2 is
			--
			-- Idle state.  Waits for a read trigger, then latches the address
			-- into an internral signal.
			--
			when X"0" =>
				if trigRead2 = '1' then
					cmdAddrRead2 <= std_logic_vector(addrRead2) & "00";					
					stateRead2 <= stateRead2 + X"1";
				else
					dataReady2 <= '0';
				end if;
			
			--
			-- Waits until the read buffer is empty and no write transactions are occurring.
			-- Sends address to command signal for memory.
			--
			when X"1" =>
				if rd_empty2 = '1' and (stateWrite2 = X"0" or stateWrite2 = X"1") then
					cmd_instr2 <= "001";		--This specifies a read command
					cmd_bl2 <= "000000";
					cmd_addr2 <= cmdAddrRead2;
					stateRead2 <= stateRead2 + X"1";
				end if;
				
			--
			-- Assert the cmd_en signal to write the cmd_instr to the
			-- controller
			--
			when X"2" =>
				cmd_en2 <= '1';
				stateRead2 <= stateRead2 + X"1";
				
			--
			-- De-assert the cmd_en signal
			--
			when X"3" =>
				cmd_en2 <= '0';
				stateRead2 <= stateRead2 + X"1";
				
			--
			-- Wait until the read buffer has data before proceeding
			--
			when X"4" =>
				if rd_empty2 = '0' then
					stateRead2 <= stateRead2 + X"1";
				end if;
				
			--
			-- Assert the rd_en signal to start pulling data from the read buffer
			--
			when X"5" =>
				rd_en2 <= '1';
				stateRead2 <= stateRead2 + X"1";
			
			--
			-- Read data is now valid.  Retrieve the data from the read buffer (rd_data)
			-- and assert that the data is valid to outside entities.
			--
			when X"6" =>
				rd_en2 <= '0';
				dataOut2 <= rd_data2;
				dataReady2 <= '1';
				stateRead2 <= stateRead2 + X"1";
			
			--
			-- De-assert the dataReady signal and return to idle state
			--
			when X"7" =>
				stateRead2 <= X"0";
				dataReady2 <= '0';
		
			when others => null;
		end case;
	end if;	--End rising_edge
end process;

StateMachine3: process(clk,trigWrite3,trigRead3) is
begin
	if rising_edge(clk) then
		--
		-- This case statement handles the process of writing data to
		-- the memory.
		--
		WriteCase3: case stateWrite3 is
			--
			-- Idle state.  Waits for a write trigger, 
			-- then latches the write address into an internal signal
			--
			when X"0" =>
				if trigWrite3 = '1' then
					wr_data3 <= dataIn3;
					cmdAddrWrite3 <= std_logic_vector(addrWrite3) & "00";
					stateWrite3 <= stateWrite3 + X"1";
				end if;
			
			--
			-- Wait until the write buffer has room and no read transactions
			-- are occurring.  Then tell the controller that a write instruction
			-- follows with one memory location to be written to.
			--
			-- Data is written into the write buffer on subsequent clock edges
			--
			when X"1" =>
				if wr_full3 = '0' and stateRead3 = X"0" then
					wr_en3 <= '1';
					stateWrite3 <= stateWrite3 + X"1";
					cmd_instr3 <= "000";		--This specifies a write command
					cmd_bl3 <= "000000";
					cmd_addr3 <= cmdAddrWrite3;
				end if;
			
			--
			-- De-asserts the write-enable signal
			--
			when X"2" =>
				wr_en3 <= '0';
				stateWrite3 <= stateWrite3 + X"1";
				
			--
			-- Waits for the write buffer to empty before proceeding
			--
			when X"3" => 
				if wr_empty3 = '0' then
					stateWrite3 <= stateWrite3 +X"1";
				end if;
				
			--
			-- This is the actual command that writes data from
			-- the write buffer into the memory
			--
			when X"4" =>
				cmd_en3 <= '1';
				stateWrite3 <= stateWrite3 + X"1";
				
			--
			-- De-assert the cmd_en signal.
			--
			when X"5" =>
				cmd_en3 <= '0';
				stateWrite3 <= stateWrite3 + X"1";
				
			--
			-- Wait until the write buffer is empty before
			-- returning to the idle state
			--
			when X"6" =>
				if wr_empty3 = '1' then
					stateWrite3 <= X"0";
				end if;
			
			when others => null;
		end case;
		
		--
		-- This case statement handles the process of reading data
		-- from the memory.
		--
		ReadCase3: case stateRead3 is
			--
			-- Idle state.  Waits for a read trigger, then latches the address
			-- into an internral signal.
			--
			when X"0" =>
				if trigRead3 = '1' then
					cmdAddrRead3 <= std_logic_vector(addrRead3) & "00";					
					stateRead3 <= stateRead3 + X"1";
				else
					dataReady3 <= '0';
				end if;
			
			--
			-- Waits until the read buffer is empty and no write transactions are occurring.
			-- Sends address to command signal for memory.
			--
			when X"1" =>
				if rd_empty3 = '1' and (stateWrite3 = X"0" or stateWrite3 = X"1") then
					cmd_instr3 <= "001";		--This specifies a read command
					cmd_bl3 <= "000000";
					cmd_addr3 <= cmdAddrRead3;
					stateRead3 <= stateRead3 + X"1";
				end if;
				
			--
			-- Assert the cmd_en signal to write the cmd_instr to the
			-- controller
			--
			when X"2" =>
				cmd_en3 <= '1';
				stateRead3 <= stateRead3 + X"1";
				
			--
			-- De-assert the cmd_en signal
			--
			when X"3" =>
				cmd_en3 <= '0';
				stateRead3 <= stateRead3 + X"1";
				
			--
			-- Wait until the read buffer has data before proceeding
			--
			when X"4" =>
				if rd_empty3 = '0' then
					stateRead3 <= stateRead3 + X"1";
				end if;
				
			--
			-- Assert the rd_en signal to start pulling data from the read buffer
			--
			when X"5" =>
				rd_en3 <= '1';
				stateRead3 <= stateRead3 + X"1";
			
			--
			-- Read data is now valid.  Retrieve the data from the read buffer (rd_data)
			-- and assert that the data is valid to outside entities.
			--
			when X"6" =>
				rd_en3 <= '0';
				dataOut3 <= rd_data3;
				dataReady3 <= '1';
				stateRead3 <= stateRead3 + X"1";
			
			--
			-- De-assert the dataReady signal and return to idle state
			--
			when X"7" =>
				stateRead3 <= X"0";
				dataReady3 <= '0';
		
			when others => null;
		end case;
	end if;	--End rising_edge
end process;

end Behavioral;

